# IndexedDB with elm-indexeddb

This example demonstrates [elm-indexeddb](https://github.com/mpizenberg/elm-indexeddb) for persistent browser storage in Elm. It implements a todo list where items survive page reloads, stored in IndexedDB via composable `ConcurrentTask` values.

## How it works

`elm-indexeddb` wraps the IndexedDB API as `ConcurrentTask` values, built on top of [elm-concurrent-task](https://github.com/andrewMacmurray/elm-concurrent-task). Phantom types enforce key discipline at compile time — the type of store determines which write operations are available.

The app defines one `InlineKey` store (key extracted from the value's `"id"` field) and performs CRUD operations:

- **On init**: opens the database, then loads all todos with `getAll`
- **On add**: inserts a new todo with `add` (fails if id already exists)
- **On toggle**: upserts the toggled todo with `put`
- **On delete**: removes a single todo with `delete`, or batch-removes completed todos with `deleteMany`

## Key patterns

### Store and schema definition

Stores are defined with phantom types that constrain which operations compile:

```elm
todosStore : Store InlineKey
todosStore = defineStore "todos" |> withKeyPath "id"

appSchema : Schema
appSchema = schema "todo-example" 1 |> withStore todosStore
```

Three store types exist:
- **`InlineKey`** — key extracted from value at a key path (`withKeyPath`). Write with `put`/`add`.
- **`ExplicitKey`** — key provided separately on every write (`defineStore` bare). Write with `putAt`/`addAt`.
- **`GeneratedKey`** — key auto-generated by IndexedDB (`withAutoIncrement`). Write with `insert`.

### Composing operations

Open the database then load data in a single task chain:

```elm
loadApp : ConcurrentTask Error ( Db, List Todo )
loadApp =
    open appSchema
        |> ConcurrentTask.andThen
            (\db ->
                getAll db todosStore todoDecoder
                    |> ConcurrentTask.map (\todos -> ( db, todos ))
            )
```

### Full API

- Read: `get`, `getAll`, `getAllKeys`, `count`
- Write (InlineKey): `put`, `add` — write (ExplicitKey): `putAt`, `addAt` — write (GeneratedKey): `insert`
- Delete: `delete`, `clear`
- Batch (single transaction): `putMany`, `putManyAt`, `insertMany`, `deleteMany`
- Concurrent reads: use `ConcurrentTask.map2`/`map3`/`map4`

### Error handling

All operations can fail with one of four typed errors:

```elm
type Error
    = AlreadyExists        -- add/addAt on existing key
    | TransactionError String
    | QuotaExceeded
    | DatabaseError String
```

Additionally, `ConcurrentTask.UnexpectedError` covers JS-side issues (missing function, decoder failure, unhandled exception).

## JS setup

The JS side imports `createTasks()` from the elm-indexeddb companion package and registers them with ConcurrentTask:

```js
import * as ConcurrentTask from "@andrewmacmurray/elm-concurrent-task";
import { createTasks } from "../elm-indexeddb/js/src/index.js";

ConcurrentTask.register({
  tasks: createTasks(),
  ports: { send: app.ports.send, receive: app.ports.receive },
});
```

## Running the example

```sh
npm install
npx elm make src/Main.elm --output=static/elm.js
npx esbuild src/index.js --bundle --outfile=static/main.js
cd static
python -m http.server 8000
```

Open `http://localhost:8000` in your browser. Add some todos, reload the page — they persist.

## Project structure

```
indexeddb/
  elm-indexeddb/    -- git submodule (the elm-indexeddb package)
  elm.json         -- Elm dependencies (source-directories includes elm-indexeddb/src)
  package.json     -- JS dependency (@andrewmacmurray/elm-concurrent-task)
  src/
    Main.elm       -- Elm app: todo list with IndexedDB persistence
    index.js       -- JS runner: registers IndexedDB tasks, wires up ports
  static/
    index.html     -- HTML shell (loads elm.js + main.js)
    elm.js         -- compiled Elm output (generated)
    main.js        -- bundled JS output (generated)
```
