# elm-indexeddb

IndexedDB support for Elm via [elm-concurrent-task](https://package.elm-lang.org/packages/andrewMacmurray/elm-concurrent-task/latest/).

Two parts: an **Elm module** (`IndexedDb`) and a **JS companion** (`elm-indexeddb`).

## Setup

### Elm

Add `elm-indexeddb/elm/src` to your app's `source-directories` in `elm.json`, and add `andrewMacmurray/elm-concurrent-task` as a dependency.

### JS

```javascript
import * as ConcurrentTask from "@andrewmacmurray/elm-concurrent-task";
import { createTasks } from "elm-indexeddb";

const app = window.Elm.Main.init({ node: document.getElementById("app") });

ConcurrentTask.register({
  tasks: createTasks(),
  ports: { send: app.ports.send, receive: app.ports.receive },
});
```

## Defining Stores

Stores use phantom types to enforce correct key usage at compile time:

```elm
import IndexedDb

-- InlineKey: key extracted from the value at "id"
todosStore : IndexedDb.Store IndexedDb.InlineKey
todosStore =
    IndexedDb.defineStore "todos"
        |> IndexedDb.withKeyPath "id"

-- GeneratedKey: key auto-generated by IndexedDB
cacheStore : IndexedDb.Store IndexedDb.GeneratedKey
cacheStore =
    IndexedDb.defineStore "cache"
        |> IndexedDb.withAutoIncrement

-- ExplicitKey: key must be provided with each write
settingsStore : IndexedDb.Store IndexedDb.ExplicitKey
settingsStore =
    IndexedDb.defineStore "settings"
```

The compiler prevents invalid combinations:

```elm
-- ERROR: withAutoIncrement expects Store ExplicitKey, got Store InlineKey
defineStore "x" |> withKeyPath "id" |> withAutoIncrement

-- ERROR: put expects Store InlineKey, got Store ExplicitKey
put db settingsStore myValue
```

## Defining a Schema

```elm
mySchema : IndexedDb.Schema
mySchema =
    IndexedDb.schema "myapp" 1
        |> IndexedDb.withStore todosStore
        |> IndexedDb.withStore cacheStore
        |> IndexedDb.withStore settingsStore
```

When you bump the version number, `open` will automatically:
- Create stores that are new in the schema
- Delete stores that are missing from the schema
- Keep existing stores with matching names as-is

## Opening the Database

```elm
import ConcurrentTask exposing (ConcurrentTask)

loadApp : ConcurrentTask IndexedDb.Error IndexedDb.Db
loadApp =
    IndexedDb.open mySchema
```

The returned `Db` handle must be threaded to all subsequent operations.

## Operations

### Reading (any store type)

```elm
IndexedDb.get db todosStore (IndexedDb.StringKey "todo-1") todoDecoder
-- ConcurrentTask Error (Maybe Todo)

IndexedDb.getAll db todosStore todoDecoder
-- ConcurrentTask Error (List Todo)

IndexedDb.getAllKeys db todosStore
-- ConcurrentTask Error (List Key)

IndexedDb.count db todosStore
-- ConcurrentTask Error Int
```

### Writing — InlineKey stores

```elm
IndexedDb.put db todosStore (encodeTodo myTodo)
-- ConcurrentTask Error Key  (upsert, returns key from value)

IndexedDb.add db todosStore (encodeTodo myTodo)
-- ConcurrentTask Error Key  (insert only, fails if key exists)
```

### Writing — ExplicitKey stores

```elm
IndexedDb.putAt db settingsStore (IndexedDb.StringKey "theme") (Encode.string "dark")
-- ConcurrentTask Error ()

IndexedDb.addAt db settingsStore (IndexedDb.StringKey "theme") (Encode.string "dark")
-- ConcurrentTask Error ()  (fails with AlreadyExists if key exists)
```

### Writing — GeneratedKey stores

```elm
IndexedDb.insert db cacheStore (Encode.object [ ... ])
-- ConcurrentTask Error Key  (always succeeds, returns generated key)
```

### Deleting (any store type)

```elm
IndexedDb.delete db todosStore (IndexedDb.StringKey "todo-1")
IndexedDb.clear db todosStore
```

### Batch Operations (single transaction)

```elm
IndexedDb.putMany db todosStore [ encodeTodo t1, encodeTodo t2 ]
IndexedDb.putManyAt db settingsStore [ ( StringKey "a", v1 ), ( StringKey "b", v2 ) ]
IndexedDb.insertMany db cacheStore [ v1, v2, v3 ]
IndexedDb.deleteMany db todosStore [ StringKey "todo-1", StringKey "todo-2" ]
```

## Keys

```elm
type Key
    = StringKey String
    | IntKey Int
    | FloatKey Float
    | CompoundKey (List Key)
```

## Errors

```elm
type Error
    = AlreadyExists        -- add/addAt on existing key
    | TransactionError String
    | QuotaExceeded
    | DatabaseError String  -- schema mismatch, DB not open, etc.
```

`get` returns `Maybe a` rather than an error when a key is missing — matching IndexedDB's native behavior.

## Migrations

Structural changes (add/remove stores) happen automatically during `open`. For data migrations, chain tasks after opening:

```elm
IndexedDb.open mySchema
    |> ConcurrentTask.andThen (\db -> migrateData db)
    |> ConcurrentTask.andThen (\db -> startApp db)
```

Track a version number in a metadata store to know which data migrations to run.
